// Generated by CoffeeScript 1.7.1
(function() {
  var cactus, checkHit, directions, display, entities, gameCanvas, iii, image, images, light, lightYScaleShift, loaded, newLight, player, propCount, propSprites, resourceCount, resources, scale, shade, sprite, updateEdges, _fn, _i, _len;

  updateEdges = function(e) {
    var centerY;
    centerY = e.type === 'light' ? e.height / 2 : 0;
    e.drawBottom = e.z - e.y + centerY;
    e.drawTop = e.z - e.y - e.height + centerY;
    e.top = e.y + e.height - centerY;
    e.bottom = e.y - centerY;
    e.front = e.z + e.depth / 2;
    e.back = e.z - e.depth / 2;
    e.right = e.x + e.width / 2;
    return e.left = e.x - e.width / 2;
  };

  directions = {
    left: {
      axis: 'x',
      multiplier: -1,
      other: 'right'
    },
    right: {
      axis: 'x',
      multiplier: 1,
      other: 'left'
    },
    up: {
      axis: 'z',
      multiplier: -1,
      other: 'down'
    },
    down: {
      axis: 'z',
      multiplier: 1,
      other: 'up'
    }
  };

  this.showDevMeshes = false;

  scale = 2;

  images = [
    {
      name: 'sprites',
      source: '/img/sprites.png'
    }, {
      name: 'sprites2',
      source: '/img/sprites2.png'
    }
  ];

  loaded = false;

  resourceCount = 0;

  this.r = resources = {
    images: {},
    audio: {}
  };

  this.e = entities = [];

  _fn = function(image) {
    var img;
    img = document.createElement('img');
    img.onload = function() {
      resources.images[image.name] = cq(img).resizePixel(scale);
      resourceCount++;
      if (resourceCount === images.length) {
        return loaded = true;
      }
    };
    return img.src = image.source;
  };
  for (_i = 0, _len = images.length; _i < _len; _i++) {
    image = images[_i];
    _fn(image);
  }

  checkHit = function(A) {
    var B, col, _j, _len1, _results;
    if (A.hit) {
      _results = [];
      for (_j = 0, _len1 = entities.length; _j < _len1; _j++) {
        B = entities[_j];
        if (B.hit && A !== B) {
          col = {
            x: A.right >= B.left && A.left <= B.right,
            z: A.front >= B.back && A.back <= B.front,
            y: A.top >= B.bottom && A.bottom <= B.top
          };
          if (col.x && col.z && col.y) {
            if (typeof A.onHit === "function") {
              A.onHit({
                x: col.x,
                z: col.z,
                y: col.y,
                other: B
              });
            }
            _results.push(typeof B.onHit === "function" ? B.onHit({
              x: col.x,
              z: col.z,
              y: col.y,
              other: A
            }) : void 0);
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };


  /*
  
  
    when a shadow object registers a hit on the light's bounding box,
    draw the object to the mask layer belonging to the light
  
    when the light is drawn, apply the light to the mask layer belonging to the light,
    and then apply the mask layer belonging to the light to the shade rendering layer
  
    draw the light colour to the rendering layer if it exists
   */

  lightYScaleShift = 0.80;

  newLight = function() {
    var light;
    light = {
      type: 'light',
      hit: true,
      x: 0,
      y: 0,
      z: 0,
      width: 0,
      height: 0,
      depth: 0,
      intensity: 1,
      radius: 0,
      fade: 0,
      color: '',
      on: false,
      toggle: function() {
        return this.on = !this.on;
      },
      set: function(opts) {
        var key, opt;
        for (key in opts) {
          opt = opts[key];
          if (this[key] != null) {
            this[key] = opt;
          }
        }
        return this;
      },
      preUpdate: function() {
        this.width = (this.radius + this.fade) * 2;
        this.height = this.width;
        this.depth = (this.radius + this.fade) * 2 * lightYScaleShift;
        if (this.y < 0) {
          return this.y = 0;
        }
      }
    };
    entities.push(light);
    return light;
  };

  entities.push(shade = {
    opacity: 0.5,
    color: '#34284b',
    type: 'shade',
    render: cq(),
    entityMask: cq(),
    lightsMask: cq(),
    lightsColor: cq(),
    updateRender: function(e, index, delta, time) {
      var belowGround, fade, intensity, light, maskLight, radius;
      if (e.type === 'light') {
        if (e.on) {
          radius = e.radius - e.y;
          fade = e.fade;
          intensity = e.intensity;
          if (radius < 0) {
            radius = 0;
            fade -= e.y - e.radius;
            if (fade < 0) {
              fade = 0;
            }
            intensity = fade / e.fade;
          }
          maskLight = this.render.createRadialGradient(0, 0, radius, 0, 0, radius + fade);
          maskLight.addColorStop(0, "rgba( 0,0,0,  " + intensity + " )");
          maskLight.addColorStop(1, "rgba( 0,0,0,  0 )");
          this.lightsMask.save().translate(e.x, e.z).scale(1, lightYScaleShift).fillStyle(maskLight).beginPath().arc(0, 0, radius + fade, 0, 2 * Math.PI).fill().restore();
          this.entityMask.save().globalCompositeOperation('destination-out').translate(e.x, e.z).fillStyle(maskLight).beginPath().arc(0, 0, radius + fade, 0, 2 * Math.PI).fill().restore();
          if (e.color) {
            light = this.lightsColor.createRadialGradient(0, 0, radius, 0, 0, radius + fade);
            light.addColorStop(0, "rgba( " + e.color + ",  " + intensity + " )");
            light.addColorStop(1, "rgba( " + e.color + ",  0 )");
            this.lightsColor.save().translate(e.x, e.z).scale(1, lightYScaleShift).fillStyle(light).beginPath().arc(0, 0, radius + fade, 0, 2 * Math.PI).fill().restore();
          }
          if (window.showDevMeshes) {
            belowGround = 0;
            if (e.y < e.height / 2) {
              belowGround = (e.height / 2) - e.y;
            }
            return this.lightsColor.save().strokeStyle('cyan').strokeRect(e.left, e.drawTop - e.depth / 2, e.width, e.height - belowGround).fillStyle('red').fillRect(e.x - 2, e.z - 2, 4, 4).strokeStyle('yellow').beginPath().moveTo(e.x, e.z).lineTo(e.x, e.z - e.y).stroke().strokeStyle('blue').beginPath().moveTo(e.left, e.drawBottom + e.depth / 2 - belowGround).lineTo(e.right, e.drawBottom - e.depth / 2 - belowGround).stroke().beginPath().moveTo(e.right, e.drawBottom + e.depth / 2 - belowGround).lineTo(e.left, e.drawBottom - e.depth / 2 - belowGround).stroke().strokeStyle('orange').beginPath().moveTo(e.left, e.drawTop + e.depth / 2).lineTo(e.right, e.drawTop - e.depth / 2).stroke().beginPath().moveTo(e.right, e.drawTop + e.depth / 2).lineTo(e.left, e.drawTop - e.depth / 2).stroke().fillStyle('green').fillRect(e.x - 2, e.z - e.y - 2, 4, 4).restore().strokeStyle('red').strokeRect(e.left, e.drawTop + e.depth / 2, e.width, e.height - belowGround);
          }
        }
      } else if (e.shadow) {
        return typeof e.draw === "function" ? e.draw(this.entityMask, delta, time, index) : void 0;
      }
    },
    draw: function(ctx, delta, time, index) {
      if (loaded) {
        this.lightsColor.save().globalCompositeOperation('destination-out').drawImage(this.entityMask.canvas, 0, 0).restore();
        this.lightsMask.save().globalCompositeOperation('destination-out').drawImage(this.entityMask.canvas, 0, 0).restore();
        this.render.save().globalCompositeOperation('destination-out').drawImage(this.lightsMask.canvas, 0, 0).restore().save().drawImage(this.lightsColor.canvas, 0, 0).restore();
        ctx.save().globalAlpha(this.opacity).drawImage(this.render.canvas, 0, 0).restore();
        this.lightsColor.clear();
        this.entityMask.clear();
        this.lightsMask.clear();
        return this.render.clear(this.color);
      }
    }
  });

  propSprites = [['sprites2', 31, 1, 40, 31, 7, 'cactus'], ['sprites2', 41, 1, 50, 41, 8, 'big cactus'], ['sprites2', 33, 34, 40, 40, 7, 'skull']];

  propCount = 5 * (window.innerHeight * window.innerWidth / 100000) / scale;

  while (propCount-- > 0) {
    sprite = propSprites[Math.floor(Math.random() * propSprites.length)];
    entities.push(this.c = cactus = {
      type: 'prop',
      spriteName: sprite[6],
      shadow: true,
      hit: true,
      x: Math.floor(Math.random() * window.innerWidth),
      z: Math.floor(Math.random() * window.innerHeight),
      y: 0,
      width: (sprite[3] - sprite[1]) * scale,
      height: (sprite[4] - sprite[2]) * scale,
      depth: sprite[5],
      rotation: 0,
      sprite: sprite,
      draw: function(ctx) {
        var frm, _ref;
        if (loaded) {
          frm = this.sprite;
          ctx.save().translate(this.left, this.drawTop).rotate(this.rotation).drawImage((_ref = resources.images[frm[0]]) != null ? _ref.canvas : void 0, frm[1] * scale, frm[2] * scale, this.width, this.height, 0, 0, this.width, this.height).restore();
          if (window.showDevMeshes) {
            return ctx.save().strokeStyle('cyan').strokeRect(this.left, this.drawTop - this.depth / 2, this.width, this.height).strokeStyle('red').strokeRect(this.left, this.drawTop + this.depth / 2, this.width, this.height).fillStyle('red').fillRect(this.x - 2, this.z - 2, 4, 4).strokeStyle('yellow').beginPath().moveTo(this.x, this.z).lineTo(this.x, this.z - this.y).stroke().fillStyle('green').fillRect(this.x - 2, this.z - this.y - 2, 4, 4).restore();
          }
        }
      }
    });
  }

  entities.push(this.p = player = {
    type: 'player',
    x: Math.floor(window.innerWidth / 2),
    z: Math.floor(window.innerHeight / 2),
    y: 0,
    width: 0,
    height: 0,
    depth: 5,
    rotation: 0,
    shadow: true,
    hit: true,
    direction: 'right',
    action: 'walk',
    force: 0.5,
    velocity: {
      x: 0,
      z: 0
    },
    light: newLight().set({
      on: false,
      y: 20,
      radius: 0,
      fade: 200,
      intensity: 1,
      color: '255,100,10'
    }),
    sprites: {
      stand: {
        left: [['sprites2', 8, 1, 14, 24]],
        right: [['sprites2', 22, 1, 28, 24]],
        up: [['sprites2', 1, 1, 7, 25]],
        down: [['sprites2', 15, 1, 21, 24]]
      },
      walk: {
        left: [['sprites2', 8, 27, 14, 50], ['sprites2', 8, 53, 14, 76], ['sprites2', 8, 79, 14, 102], ['sprites2', 8, 105, 14, 128]],
        right: [['sprites2', 22, 27, 28, 50], ['sprites2', 22, 53, 28, 76], ['sprites2', 22, 79, 28, 102], ['sprites2', 22, 105, 28, 128]],
        up: [['sprites2', 1, 27, 7, 50], ['sprites2', 1, 53, 7, 76], ['sprites2', 1, 79, 7, 102], ['sprites2', 1, 105, 7, 128]],
        down: [['sprites2', 15, 27, 21, 50], ['sprites2', 15, 53, 21, 76], ['sprites2', 15, 79, 21, 102], ['sprites2', 15, 105, 21, 128]]
      }
    },
    currentFrame: void 0,
    frame: 0,
    frameTimer: 0,
    frameSpeed: 5,
    keys: {
      f: {
        pressed: false,
        action: function(key) {
          if (this.pressed) {
            return player.light.toggle();
          }
        }
      },
      left: {
        pressed: false,
        action: function(key) {
          return player.move(key);
        }
      },
      right: {
        pressed: false,
        action: function(key) {
          return player.move(key);
        }
      },
      up: {
        pressed: false,
        action: function(key) {
          return player.move(key);
        }
      },
      down: {
        pressed: false,
        action: function(key) {
          return player.move(key);
        }
      }
    },
    move: function(name) {
      var direction, key;
      key = this.keys[name];
      direction = directions[name];
      this.velocity[direction.axis] = this.force * direction.multiplier * (key.pressed ? 1 : 0);
      if (this.keys[direction.other].pressed && !key.pressed) {
        this.move(direction.other);
      }
    },
    preUpdate: function() {
      var action, _ref;
      action = (_ref = this.sprites[this.action]) != null ? _ref[this.direction] : void 0;
      if (action[this.frame] == null) {
        this.frame = 0;
      }
      this.currentFrame = action[this.frame];
      this.width = (this.currentFrame[3] - this.currentFrame[1]) * scale;
      this.height = (this.currentFrame[4] - this.currentFrame[2]) * scale;
      if (this.frameTimer++ >= (this.currentFrame[5] || this.frameSpeed)) {
        this.frameTimer = 0;
        return this.frame++;
      }
    },
    update: function() {
      this.x += this.velocity.x * scale;
      this.z += this.velocity.z * scale;
      this.direction = this.velocity.z > 0 ? 'down' : this.velocity.z < 0 ? 'up' : this.velocity.x > 0 ? 'right' : this.velocity.x < 0 ? 'left' : this.direction;
      this.action = !this.velocity.x && !this.velocity.z ? 'stand' : 'walk';
      this.light.set({
        x: this.left + (this.direction === 'right' || this.direction === 'down' ? this.width + 3 : -3),
        z: this.drawBottom + (this.direction === 'up' || this.direction === 'right' ? -3 - this.depth / 2 : 3 + this.depth / 2)
      });
    },
    draw: function(ctx) {
      var frm, _ref;
      if (loaded) {
        frm = this.currentFrame;
        if (frm != null) {
          ctx.save().translate(this.left, this.drawTop).rotate(this.rotation).drawImage((_ref = resources.images[frm[0]]) != null ? _ref.canvas : void 0, frm[1] * scale, frm[2] * scale, this.width, this.height, 0, 0, this.width, this.height).restore();
          if (window.showDevMeshes) {
            return ctx.save().strokeStyle('cyan').strokeRect(this.left, this.drawTop - this.depth / 2, this.width, this.height).strokeStyle('red').strokeRect(this.left, this.drawTop + this.depth / 2, this.width, this.height).fillStyle('red').fillRect(this.x - 2, this.z - 2, 4, 4).strokeStyle('yellow').beginPath().moveTo(this.x, this.z).lineTo(this.x, this.z - this.y).stroke().fillStyle('green').fillRect(this.x - 2, this.z - this.y - 2, 4, 4).restore();
          }
        }
      }
    }
  });

  entities.push(display = {
    type: 'display',
    render: cq(),
    updateWait: 10,
    updateCount: 0,
    x: 10,
    z: 10,
    draw: function(ctx, delta, time) {
      var text;
      if (this.updateCount === 0) {
        text = "Change 'showDevMeshes' in the console. Press 'f'   ||   " + entities.length + " entities | x: " + player.x + ", z: " + player.z + " | d" + delta;
        this.render.clear().save().textBaseline('top').font('20px consolas').fillStyle('white').fillText(text, 0, 0).restore();
      }
      if (this.updateCount++ > this.updateWait) {
        this.updateCount = 0;
      }
      return ctx.save().translate(this.x, this.z).drawImage(this.render.canvas, 0, 0).restore();
    }
  });

  this.l = light = newLight().set({
    on: true,
    radius: 40,
    fade: 40,
    x: window.innerWidth / 2 + 20,
    z: window.innerHeight / 2,
    y: 150
  });

  iii = 0;

  gameCanvas = cq().framework({
    onresize: function(width, height) {
      this.canvas.width = width;
      this.canvas.height = height;
    },
    onmousemove: function(x, z) {
      return light.set({
        x: x,
        y: light.z - z
      });
    },
    onkeydown: function(key) {
      var _ref;
      if ((player.keys[key] != null) && !((_ref = player.keys[key]) != null ? _ref.pressed : void 0)) {
        player.keys[key].pressed = true;
        player.keys[key].action(key);
      }
    },
    onkeyup: function(key) {
      var _ref;
      if ((_ref = player.keys[key]) != null ? _ref.pressed : void 0) {
        player.keys[key].pressed = false;
        player.keys[key].action(key);
      }
    },
    onrender: function(delta, time) {
      var entity, i;
      this.clear('#f8e8c3');
      for (i in entities) {
        entity = entities[i];
        if (typeof entity.preUpdate === "function") {
          entity.preUpdate(parseInt(i), delta, time);
        }
        updateEdges(entity);
        checkHit(entity);
        if (typeof entity.update === "function") {
          entity.update(parseInt(i), delta, time);
        }
        shade.updateRender(entity, parseInt(i), delta, time);
      }
      entities.sort(function(a, b) {
        if ((a.height == null) && (b.height == null)) {
          return 0;
        } else if (a.height == null) {
          return 1;
        } else if (b.height == null) {
          return -1;
        }
        return a.z - b.z;
      });
      for (i in entities) {
        entity = entities[i];
        if (typeof entity.draw === "function") {
          entity.draw(this, delta, time, parseInt(i));
        }
      }
      iii++;
    }
  }).appendTo('body');

}).call(this);
