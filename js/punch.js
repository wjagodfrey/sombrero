// Generated by CoffeeScript 1.7.1
(function() {
  var cactus, checkHit, directions, display, entities, gameCanvas, gravity, iii, image, images, loaded, player, propCount, propSprites, resourceCount, resources, scale, sprite, updateEdges, _fn, _i, _len;

  updateEdges = function(e) {
    e.drawBottom = e.z - e.y;
    e.drawTop = e.z - e.y - e.height;
    e.top = e.y + e.height;
    e.bottom = e.y;
    e.front = e.z + e.depth;
    e.back = e.z;
    e.right = e.x + e.width / 2;
    return e.left = e.x - e.width / 2;
  };

  directions = {
    left: {
      axis: 'x',
      multiplier: -1,
      other: 'right'
    },
    right: {
      axis: 'x',
      multiplier: 1,
      other: 'left'
    },
    up: {
      axis: 'z',
      multiplier: -1,
      other: 'down'
    },
    down: {
      axis: 'z',
      multiplier: 1,
      other: 'up'
    }
  };

  this.showDevMeshes = false;

  scale = 2;

  gravity = 0.04;

  images = [
    {
      name: 'sprites2',
      source: './img/sprites2.png'
    }
  ];

  loaded = false;

  resourceCount = 0;

  this.r = resources = {
    images: {},
    audio: {}
  };

  this.e = entities = [];

  _fn = function(image) {
    var img;
    img = document.createElement('img');
    img.onload = function() {
      resources.images[image.name] = cq(img).resizePixel(scale);
      resourceCount++;
      if (resourceCount === images.length) {
        return loaded = true;
      }
    };
    return img.src = image.source;
  };
  for (_i = 0, _len = images.length; _i < _len; _i++) {
    image = images[_i];
    _fn(image);
  }

  checkHit = function(A, i, delta, time) {
    var B, col, _j, _len1, _results;
    if (A.hit) {
      _results = [];
      for (_j = 0, _len1 = entities.length; _j < _len1; _j++) {
        B = entities[_j];
        if (B.hit && A !== B) {
          col = {
            x: A.right >= B.left && A.left <= B.right,
            z: A.front >= B.back && A.back <= B.front,
            y: A.top >= B.bottom && A.bottom <= B.top
          };
          if (col.x && col.z && col.y) {
            if (typeof A.onHit === "function") {
              A.onHit({
                other: B
              }, i, delta, time);
            }
            _results.push(typeof B.onHit === "function" ? B.onHit({
              other: A
            }, i, delta, time) : void 0);
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  propSprites = [['sprites2', 31, 1, 40, 31, 7, 'cactus'], ['sprites2', 41, 1, 50, 41, 8, 'big cactus'], ['sprites2', 33, 37, 41, 42, 7, 'skull']];

  propCount = 20 * (window.innerHeight * window.innerWidth / 100000) / scale;

  while (propCount-- > 0) {
    sprite = propSprites[Math.floor(Math.random() * propSprites.length)];
    entities.push(this.c = cactus = {
      type: 'prop',
      spriteName: sprite[6],
      shadow: true,
      hit: true,
      x: Math.floor(Math.random() * window.innerWidth),
      z: Math.floor(Math.random() * window.innerHeight),
      y: 0,
      width: (sprite[3] - sprite[1]) * scale,
      height: (sprite[4] - sprite[2]) * scale,
      depth: sprite[5],
      rotation: 0,
      sprite: sprite,
      draw: function(ctx, delta, time, index) {
        var frm, _ref;
        if (loaded) {
          frm = this.sprite;
          ctx.save().translate(this.left, this.drawTop).rotate(this.rotation).drawImage((_ref = resources.images[frm[0]]) != null ? _ref.canvas : void 0, frm[1] * scale, frm[2] * scale, this.width, this.height + (4 * scale), 0, 0, this.width, this.height + (4 * scale)).restore();
          if (window.showDevMeshes) {
            return ctx.save().strokeStyle('cyan').strokeRect(this.left, this.drawTop, this.width, this.height).strokeStyle('red').strokeRect(this.left, this.drawTop + this.depth, this.width, this.height).fillStyle('red').fillRect(this.x - 2, this.z - 2, 4, 4).strokeStyle('yellow').beginPath().moveTo(this.x, this.z).lineTo(this.x, this.z - this.y).stroke().fillStyle('green').fillRect(this.x - 2, this.z - this.y - 2, 4, 4).restore();
          }
        }
      }
    });
  }

  entities.push(this.p = player = {
    type: 'player',
    x: Math.floor(window.innerWidth / 2),
    z: Math.floor(window.innerHeight / 2),
    y: 0,
    width: 0,
    height: 0,
    depth: 5,
    rotation: 0,
    shadow: true,
    hit: true,
    direction: 'right',
    action: 'stand',
    force: 0.5,
    velocity: {
      x: 0,
      y: 0,
      z: 0
    },
    sprites: {
      stand: {
        left: [['sprites2', 8, 1, 14, 23]],
        right: [['sprites2', 22, 1, 28, 23]],
        up: [['sprites2', 1, 1, 7, 23]],
        down: [['sprites2', 15, 1, 21, 23]]
      },
      walk: {
        left: [['sprites2', 8, 30, 14, 52], ['sprites2', 8, 59, 14, 81], ['sprites2', 8, 88, 14, 110], ['sprites2', 8, 117, 14, 139]],
        right: [['sprites2', 22, 30, 28, 52], ['sprites2', 22, 59, 28, 81], ['sprites2', 22, 88, 28, 110], ['sprites2', 22, 117, 28, 139]],
        up: [['sprites2', 1, 30, 7, 52], ['sprites2', 1, 59, 7, 81], ['sprites2', 1, 88, 7, 110], ['sprites2', 1, 117, 7, 139]],
        down: [['sprites2', 15, 30, 21, 52], ['sprites2', 15, 59, 21, 81], ['sprites2', 15, 88, 21, 110], ['sprites2', 15, 117, 21, 139]]
      }
    },
    currentFrame: void 0,
    frame: 0,
    frameTimer: 0,
    frameSpeed: 5,
    keys: {
      left: {
        pressed: false,
        action: function(key) {
          return player.move(key);
        }
      },
      right: {
        pressed: false,
        action: function(key) {
          return player.move(key);
        }
      },
      up: {
        pressed: false,
        action: function(key) {
          return player.move(key);
        }
      },
      down: {
        pressed: false,
        action: function(key) {
          return player.move(key);
        }
      }
    },
    move: function(name) {
      var direction, key;
      key = this.keys[name];
      direction = directions[name];
      this.velocity[direction.axis] = this.force * direction.multiplier * (key.pressed ? 1 : 0);
      if (this.keys[direction.other].pressed && !key.pressed) {
        this.move(direction.other);
      }
    },
    onHit: function(hit) {
      var o;
      o = hit.other;
      if (o.y + o.height < this.y + this.height / 4) {
        this.y = o.y + o.height;
        return updateEdges(this);
      } else {

      }
    },
    preUpdate: function() {
      var action, _ref;
      this.velocity.y -= gravity;
      action = (_ref = this.sprites[this.action]) != null ? _ref[this.direction] : void 0;
      if (action[this.frame] == null) {
        this.frame = 0;
      }
      this.currentFrame = action[this.frame];
      this.width = (this.currentFrame[3] - this.currentFrame[1]) * scale;
      this.height = (this.currentFrame[4] - this.currentFrame[2]) * scale;
      if (this.frameTimer++ >= (this.currentFrame[5] || this.frameSpeed)) {
        this.frameTimer = 0;
        return this.frame++;
      }
    },
    update: function() {
      this.x += this.velocity.x * scale;
      this.y += this.velocity.y * scale;
      this.z += this.velocity.z * scale;
      if (this.y < 0) {
        this.y = 0;
      }
      this.direction = this.velocity.z > 0 ? 'down' : this.velocity.z < 0 ? 'up' : this.velocity.x > 0 ? 'right' : this.velocity.x < 0 ? 'left' : this.direction;
      this.action = !this.velocity.x && !this.velocity.z ? 'stand' : 'walk';
    },
    draw: function(ctx) {
      var frm, _ref;
      if (loaded) {
        frm = this.currentFrame;
        if (frm != null) {
          ctx.save().translate(this.left, this.drawTop).rotate(this.rotation).drawImage((_ref = resources.images[frm[0]]) != null ? _ref.canvas : void 0, frm[1] * scale, frm[2] * scale, this.width, this.height + (4 * scale), 0, 0, this.width, this.height + (4 * scale)).restore();
          if (window.showDevMeshes) {
            return ctx.save().strokeStyle('cyan').strokeRect(this.left, this.drawTop - this.depth / 2, this.width, this.height).strokeStyle('red').strokeRect(this.left, this.drawTop + this.depth / 2, this.width, this.height).fillStyle('red').fillRect(this.x - 2, this.z - 2, 4, 4).strokeStyle('yellow').beginPath().moveTo(this.x, this.z).lineTo(this.x, this.z - this.y).stroke().fillStyle('green').fillRect(this.x - 2, this.z - this.y - 2, 4, 4).restore();
          }
        }
      }
    }
  });

  entities.push(display = {
    type: 'display',
    render: cq(),
    updateWait: 10,
    updateCount: 0,
    x: 10,
    z: 10,
    draw: function(ctx, delta, time) {
      var text;
      if (this.updateCount === 0) {
        text = "" + entities.length + " entities | x: " + player.x + ", z: " + player.z + " , y: " + player.y + " | d" + delta;
        this.render.clear().save().textBaseline('top').font('20px consolas').fillStyle('white').fillText(text, 0, 0).restore();
      }
      if (this.updateCount++ > this.updateWait) {
        this.updateCount = 0;
      }
      return ctx.save().translate(this.x, this.z).drawImage(this.render.canvas, 0, 0).restore();
    }
  });

  iii = 0;

  gameCanvas = cq().framework({
    onresize: function(width, height) {
      this.canvas.width = width;
      this.canvas.height = height;
    },
    onmousemove: function(x, z) {},
    onkeydown: function(key) {
      var _ref;
      if ((player.keys[key] != null) && !((_ref = player.keys[key]) != null ? _ref.pressed : void 0)) {
        player.keys[key].pressed = true;
        player.keys[key].action(key);
      }
    },
    onkeyup: function(key) {
      var _ref;
      if ((_ref = player.keys[key]) != null ? _ref.pressed : void 0) {
        player.keys[key].pressed = false;
        player.keys[key].action(key);
      }
    },
    onrender: function(delta, time) {
      var entity, i;
      if (loaded) {
        iii++;
      }
      this.clear('#f8e8c3');
      for (i in entities) {
        entity = entities[i];
        i = parseInt(i);
        if (typeof entity.preUpdate === "function") {
          entity.preUpdate(i, delta, time);
        }
        updateEdges(entity);
        checkHit(entity, i, delta, time);
        if (typeof entity.update === "function") {
          entity.update(i, delta, time);
        }
      }
      entities.sort(function(a, b) {
        if ((a.height == null) && (b.height == null)) {
          return 0;
        } else if (a.height == null) {
          return 1;
        } else if (b.height == null) {
          return -1;
        }
        return a.z - b.z;
      });
      for (i in entities) {
        entity = entities[i];
        if (typeof entity.draw === "function") {
          entity.draw(this, delta, time, parseInt(i));
        }
      }
    }
  }).appendTo('body');

}).call(this);
